아주 오래 전에 중학교때인가, 고등학교 때인가, “마이크로 소프트웨어”라는 잡지를 보면서 computer geek들이 리눅스를 가지고, PC를 돌리는 이야기를 본적이 있었고,



사회생활 하면서는 웹서버에서 리눅스를 OS로 사용한다는 이야기를 들었지만, 실제로 리눅스를 써본 것은 이제 겨우 약 2~3개월 남짓 된다. 주로 회사생활을 했기  때문에 회사에서는 windows환경이고, 분업이 잘 이루어진 회사에서 일반 직원이 서버를 접할 수 있는 기회는 많지 않기 때문이다.



하지만 관광빅데이터 분석대회를 하면서 (주로 내 R프로그래밍 코딩 능력의 부족에 기인한 것이지만…) “상금을 타지 못한 이유는” PC가 나뻐서 라는 미명하에 새로운 Desktop PC를 사면서, 램 확장 슬롯이 4개  Max 32M 가능하고, 그래픽 카드가 내장된 최신 64bit i7 CPU를 가진 수치계산전용 PC로 사양을 정하고, 아예 OS를 리눅스로 해버렸다.



지금은 테스크탑용 리눅스가 거의 윈도우 비슷하게 기능을 하는데, 특별히 게임을 하거나, acticeX로 된 은행거래만 아니라면, 거의 불편함이 없이 PC를 이용할 수 있다. 자녀분들이 게임으로 시간을 낭비하는 경우가 많다면, 리눅스를 깔면 업무와 공부는 그냥 그대로 하면서 게임은 자연스럽게 못하게할 수도 있을 듯하다.



다만 이는 리눅스 배포판 작성자 들이 예상해서 만들어 놓은 일반적인 활용 범위내에서의 일인데, 약간만 내가 원하는 것을 적용할려고 하면, 그 유명한 CLI(Command Line Interface)를 사용해야 만 한다.



예를 들면, PC에 하드디스크를 추가할려고 하면 윈도우 환경에서는 자동으로 인식을 하는 경우가 일반적인데, 리눅스에서는 세팅을 별도로 해주어야 한다. 어쩔때는 잘 인식하던 모니터를 인식못하는 경우도 생기는데, 워낙 version up을 자주하는데다가, 매우 광대한 기능을 가지고 있어서, 상황에 따라서는 이런 오류도 발생한다.



물론 몇일이면 다시 patch가 되지만, 일반인들의 경우는 “뭐 이래…” 하면서 “역시 윈도우즈야” 하는데, 웹에서 해결방법을 찾는 노하우를 몸으로 익히고, 검색되어진 잡다한 방법중에서 내가 필요한 방법을 골라내는 경험을 몇번만 해보게 되면, 이게 더 편해진다.



이런 것이 오픈 소스의 단점이기도 하고 장점이기도 한 것 같다. 내가 불편해도 직접해결하지 않으면, 딱히 누구에게 하소연 할 수도 없다고 생각할 수도 있지만, 누군가는 분명히 이런 문제를 가지고 고민해서 해결책을 올려놓았을 것이기 때문에 웹을 검색하면 대부분 문제가 해결이 된다. 다만, 이런 문턱을 넘지 못하면 “마음”이 상해서 친해지기 어렵다는게 문제인데, 영리를 목적으로 한 기업이라면 기를 쓰고 고치겠지만, 이 분들은 느긋하다. 그래서 마음에 든다. (내가 특이하긴 특이한 모양이다. ㅋㅋㅋ)



이런 믿음이 생길려면 몇번 고생을 해야 하는데, 이 고비만 넘기면, 이제 굉장한 자유가 생긴다.  “유료 소프트웨어”가 필요없는 세상으로 들어가는 열쇠를 받았기 때문이다.



그리고, 이러한 불안정성내지는 불편함은 일반인을 대상으로 하는 데스트탑 리눅스의  경우이지, 서버쪽으로 가면 안정성을 최우선으로 하고, 리눅스업계 입장에서도 주요한 “수입원”이기 때문에 관리도 더 정성스럽게 할 것이 분명하고, 쓸데 없는 오류가 아예 없도록 아무나 쓰지 못하게 아예 Command Line Interface를 디폴트로 설정해놓아서, 아예 손도 못대거나, 아니면 그 엄청난 computing power를 하인 부리 듯 사용하거나 둘중의 하나의 길로 들어서게 만든다.



최근에 Amazon Cloud service인 EC2에 가입하면서, Amazon의 promotion인 600M ram에 8G 하드용량의 서버를 1년간 무상으로 사용하게되고, putty등의 텔넷 프로그램으로 원격접속으로 서버를 관리하고, 블로그를 운영하면서, 이 리눅스를 매우 자주 접하게 되었는데,



(이렇게 원격접속을 이용해서 웹서버도 설치하고, database도 세팅하고, 파일 이용권한도 바꿔주고 하다 보면 내가 진짜 “무언가”를 한다는 느낌이 들어, 친근해지는 지름길이 되는 것 같습니다.)



지금은 장난감같은 서버를 가지고 training을 하는 중이지만 나중에는 Netflix처럼 미국 전체 인터넷 traffic의 30%를, 이 Amazon의 cloud서비스를 통해서 할 지도 모른다고 생각을 바꾸면, 자세를 바로잡게 된다.



(ㅋㅋㅋ.. 생각만으로도 기분이 좋아진다… ^________^)



하지만, 아무래도 ad hoc 베이스로 배운 실력이라 불안해서, 정규과정을 찾다가 edX에서 하는  이 리눅스 기초 과정을 알게 되었다.



(최근에는 이렇게 MOOC에 처음 등장하는 프로그램이 많다. 얼마전에는 서울대 교수님이 하는 강좌도 있는 것을 본 것 같다.)



근데, 뭐 교육과정 자체는 내가 들었던 다른 MOOC에 비해서는 그렇게 재미는 없다. 하지만 그래도 리눅스를 전문으로 관리하는 사람들이 만든 강좌라서 조금 딱딱하긴 하지만 리눅스를 체계적으로 배울 수 있는 기회라서 좋았다.



(리눅스라는게 원래 이런 성격을 가지고 있어서 교육도 그런 느낌이 드는 것 같아요.)



리눅스를 배우고, 자바 프로그래밍을 배우면서 느낀 점은 이런 부분들이 R이나 다른 오픈소스 소프트웨어에 그 자취를 남기고 있다는 점이다. 아마도 C도 그럴 것 같은데, 다 배우고 싶지만 당장은 그럴만한 여력이 없는게 아쉽다.



지금 현재의 트렌드는 OS야 당근 리눅스이고, 프로그래밍 언어는 데이터 처리용으로는 python(직접 데이터 핸들링 할때 사용한다)과 Java(하둡등이 이 언어로 개발되어서, 남이 만든 코드를 이해하는 수준까지는 빌드업이 필요하다.), 통계 분석은 R, 웹프로그래밍은 클라이언트 수준에서는 javascript, 서버단에서는 php 등인 것 같다.



물론 새로운 소프트웨어들이 계속나오지만 이정도면 대략 end-to-end로 업무를 보는 것이 가능해지고, 부가가치를 만들어 낼수 있는 수준이 될 수 있다.



물론 배우는 것은 기초이고 활용은 그 다음의 문제이기는 하다. 밑져야 본전이고 잘되면 Airbnb같은 기업의 사장도 될 수 있는 기반이 되어줄 수도 있다.



그러고 보니 1년전의 막막함과는 달리, MOOC의 도움으로 거의 무료로 이러한 기초 공부를 거의 마무리 해가는데, 이제 python과 php만 공부하면 될 것같다. php는 생활코딩 강의를 들으면 될 것 같은데, python이 문제다.



python은 종류가 두가지이다. 오픈 소스에서는 이런일이 자주 있는가 본데,  2.7과 3.4 버전 두가지가 있다. 그리고 서로 호환이 안되는 부분이 있다. 그래서 선택을 해야 하는데, 수치계산용으로는 2.7이 가용한 라이브러리가 많아서 권장된다고 한다. 일단, ADP 실기 시험 및 빅콘테스트 끝나고 나면, 이 두가지 인 듯 3가지인 언어에 도전을 해봐야 겠다.



아래에 보이는 분이, 리눅스를 만드는 Seed를 뿌리시고, 지금은 이를 직접 관리하고 계신 리누스 토발즈이다. 아마 이 강좌도 횟수가 지나서, 리눅스에 애정을 가진 학생들이 개선안을 내고 이것들이 반영되면, 더욱 쉬운듯이 배울 수 있게 교육 경험이 좋아질 것으로 예상된다.



하지만 여전히 현재까지는 가장 효율적으로 방대한 리눅스의 기초를 잡는 유용한 교육임에는 틀림이 없는 것 같다.





 



 



히히, 늦었지만 Java 프로그래밍 관련 강좌소개로 마무리를 하고자 한다. amount를  “어망~”으로 발음하시는 우리 홍콩대학교의 TC Pong교수님께 감사를 드리고, 존경을 표합니다.



꼭 시골 아저씨 같은 포스를 뿜어내시는 교수님의 열정과 동료들의 도움으로 완전히 이해는 못했지만, Object Oriented Programming이 무엇인지 대략적인 감은 잡았고, 남이 만든 코드를 이해할 수 있는 수준은 된 것 같습니다.





그래서 책에서 자바코드를 보고 “코사인 유사도”를 계산하는 방법을 R로 만들 수도 있게 되었습니다. 다음으로 예정된 Pong 교수님의 안드로이드 프로그래밍 강좌도 들어보고 싶다. 오늘 Pong교수님 목소리 들으러 Class Archive로 들어가 봐야 겠다. 하하하.





purchase <- matrix(0,10,10)

edges <- matrix(c(1,2,1,3,1,4,1,8,

                  2,5,2,6,2,7,

                  3,1,3,2,3,3,3,4,3,6,3,7,3,8,3,9,

                  4,1,4,2,4,5,4,6,4,8,4,10,

                  5,1,5,2,5,4,5,6,5,7,5,8,5,10,

                  6,3,6,9,

                  7,6,

                  8,2,8,4,8,6,8,7,8,10,

                  9,1,9,2,9,6,9,7,9,8,9,10,

                  10,1,10,2,10,4,10,5),

                byrow=T, ncol=2)

purchase[edges] <- 1

colnames(purchase) <- paste0("p", 1:10)

rownames(purchase) <- paste0("c", 1:10)

purchase



data <- t(purchase) # 상품기준으로 하기위해 데이터를 transpose했다.

data

cosSimilar <- matrix(0, dim(data)[1], dim(data)[1])

colnames(cosSimilar) <- paste0("p",1:dim(data)[1])

rownames(cosSimilar) <- paste0("p",1:dim(data)[1])



for (i in 1:dim(data)[1]) {

  for (j in 1:dim(data)[1]) {

    up <- t(data[i,]) %*% data[j,] # sum(xi*yi)

    bottomA <- sum(data[i,]^2)     # sum(xi^2)

    bottomB <- sum(data[j,]^2)     # sum(yi^2)

    bottom <- sqrt(bottomA) %*% sqrt(bottomB)

    cosSimilar[i,j] <- up / bottom

  }  

}

round(cosSimilar,3)

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

purchase <- matrix(0,10,10)

edges <- matrix(c(1,2,1,3,1,4,1,8,

                  2,5,2,6,2,7,

                  3,1,3,2,3,3,3,4,3,6,3,7,3,8,3,9,

                  4,1,4,2,4,5,4,6,4,8,4,10,

                  5,1,5,2,5,4,5,6,5,7,5,8,5,10,

                  6,3,6,9,

                  7,6,

                  8,2,8,4,8,6,8,7,8,10,

                  9,1,9,2,9,6,9,7,9,8,9,10,

                  10,1,10,2,10,4,10,5),

                byrow=T, ncol=2)

purchase[edges] <- 1

colnames(purchase) <- paste0("p", 1:10)

rownames(purchase) <- paste0("c", 1:10)

purchase

 

data <- t(purchase) # 상품기준으로 하기위해 데이터를 transpose했다.

data

cosSimilar <- matrix(0, dim(data)[1], dim(data)[1])

colnames(cosSimilar) <- paste0("p",1:dim(data)[1])

rownames(cosSimilar) <- paste0("p",1:dim(data)[1])

 

for (i in 1:dim(data)[1]) {

  for (j in 1:dim(data)[1]) {

    up <- t(data[i,]) %*% data[j,] # sum(xi*yi)

    bottomA <- sum(data[i,]^2)     # sum(xi^2)

    bottomB <- sum(data[j,]^2)     # sum(yi^2)

    bottom <- sqrt(bottomA) %*% sqrt(bottomB)

    cosSimilar[i,j] <- up / bottom

  }  

}

round(cosSimilar,3)

20140901_introduction to programming with JAVACertificate